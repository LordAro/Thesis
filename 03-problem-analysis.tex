\chapter{Problem Analysis}\label{ch:problemanalysis}
The objective of this project is to create a program that can run
register-based assembly instructions on an emulated stack machine, and implement
optimisation techniques that show improved execution times over the basic
implementation.

The program implementation should be broken down into a number of steps. First
will be deciding on the source (register) and target (stack) architectures.  The
first part of the implementation will be to implement emulators for the chosen
architectures.  Some conversion routines for register to stack architectures
will be then implemented. After this, the generated stack code will have
optimisation techniques applied to it. Finally, suitable test programs will be
written.

\section{Requirements}
The following is a codified list of key features for the implementation of
the project that are required for the project to properly succeed:

\begin{enumerate}[noitemsep,label=R\arabic*]
  \item Fully functioning emulator for a register machine
    architecture\label{itm:register}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Working parser
    \item Implement basic interpreter
    \item Implement all instructions
  \end{enumerate}
  \item Fully functioning emulator for a stack machine
    architecture\label{itm:stack}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Working parser
    \item Implement basic interpreter
    \item Implement all instructions
  \end{enumerate}
  \item Ability to generate stack code from register code\label{itm:generate}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Implement conversions for all register instructions
    \item Transpiler --- translate entire program and output the result
    \item Translate code in blocks at a time
  \end{enumerate}
  \item Apply optimisations to the generated stack code\label{itm:optimise}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Peephole optimisations
    \item Koopman-style stack scheduling optimisations
  \end{enumerate}
  \item Series of results that show significance of optimisation of generated
    stack code\label{itm:results}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Compare number of register instructions with the number of generated
      stack instructions
    \item Show reduction in instruction count of optimised stack code
    \item Show reduction in memory accesses of generated stack code after
      optimisations
  \end{enumerate}
\end{enumerate}

\noindent There are also a certain number of desirable features that are
optional for the project.

\begin{enumerate}[noitemsep,resume,label=R\arabic*]
  \item Additional stack optimisations on the generated stack
    code\label{itm:moreoptimise}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Bailey's optimisation algorithm
    \item Shannon's optisation algorithm
  \end{enumerate}
  \item Implement translation block caching\label{itm:caching}
  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
    \item Cache converted blocks
    \item Implement a translation threshold --- like the Transmeta
      implementation, only translate regions of code if they are executed more
      than a certain number of times
  \end{enumerate}
  \item Ability to more easily visualise differences between handwritten and
    generated code, e.g.\ graphs or running side-by-side\label{itm:visualise}
\end{enumerate}
%  \begin{enumerate}[noitemsep,label=\theenumi.\arabic*]
%  \end{enumerate}

The degree to which these objectives are successful will be discussed in
Section~\ref{sec:testingevaluation} and further work according to which points
are not completed will be discussed in Section~\ref{sec:furtherwork}.
